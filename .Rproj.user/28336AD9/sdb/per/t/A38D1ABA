{
    "collab_server" : "",
    "contents" : "# this script correct raw expression data by removing principal components\n\nlibrary(argparser)\nlibrary(data.table)\nlibrary(svd)\nlibrary(preprocessCore)\nlibrary(limma)\n\nargs <- arg_parser('program')\n\nargs <- add_argument(args, '-expr',\n                     help='expression data file (gene x sample)',\n                     default='/work-zfs/abattle4/lab_data/GTEx_v8/processed/rna_seq_by_tissue/gene_tpm/WholeBlood.txt')\nargs <- add_argument(args, '-pc',\n                     help='number of PCs to remove',\n                     default=5)\nargs <- add_argument(args, '-st',\n                     help='column number actual data start at (note: gene names at first col)',\n                     default=3)\nargs <- add_argument(args, '-log',\n                     help='log transform',\n                     default=TRUE)\nargs <- add_argument(args, '-quantile',\n                     help='quantile transform',\n                     default=TRUE)\nargs <- add_argument(args, '-tpm',\n                     help='min given tpm in at least some number of samples',\n                     default=1)\nargs <- add_argument(args, '-sample',\n                     help='min tpm in at least given number of samples',\n                     default=10)\nargs <- add_argument(args, '-o',\n                     help='output file',\n                     default='results/pc_corrected_expr.txt')\n\nargv = parse_args(args)\nexpr_fn = argv$expr\nstart_col = argv$st\nn_pc = argv$pc\ndo_log = argv$log\ndo_quantile = argv$quantile\nmin_tpm = argv$tpm\nmin_samples = argv$sample\nout_fn = argv$o\n\n\n### read util\nread_df <- function(fn, sep = '\\t',  header = T, quote = \"\", row.names=T, stringsAsFactors = F, check.names = F, lessColInHeader=F, skip = 0){\n  if(header==T && lessColInHeader==T){\n    header_line = readLines(fn, n = 1)\n    headers = strsplit(header_line, split = sep)[[1]]\n    skip = skip + 1\n  }\n  \n  data_df = fread(fn, \n                  sep = sep,\n                  header = header & !lessColInHeader, \n                  skip = skip,\n                  quote = quote,    # not available in old package\n                  stringsAsFactors = stringsAsFactors, \n                  check.names = check.names, \n                  data.table = FALSE)\n  if (row.names == TRUE){\n    rownames(data_df) = data_df[,1]\n    data_df = data_df[,-1, drop=F]\n  }\n  if(header==T && lessColInHeader==T){\n    colnames(data_df) = headers\n  }\n  return(data_df)\n}\n\n### read expression\nexpr_df = read_df(fn = expr_fn, sep = '\\t', header = T, quote = \"\", row.names = T, stringsAsFactors = F, lessColInHeader = F)\nstart_col_df = NULL\nif (start_col>2){\n  start_col_df = expr_df[,1:(start_col-2), drop=F]\n  expr_df = expr_df[,-(1:(start_col-2))]\n}\n\n### filter on TPM\nfilter_on_tpm_read <- function(expr.df, tpm.df, min.tpm = 0.1, min.samples = 10){\n  # expr.df gene x sample dataframe\n  \n  ### make sure matrices have the same order as expr.df\n  features = rownames(expr.df)\n  samples = colnames(expr.df)\n  tpm.df <- tpm.df[features, samples]\n  \n  ### filter\n  n_samples_w_min_tpm <- apply(tpm.df>min.tpm, 1, sum)\n  has.min.samples <- (n_samples_w_min_tpm >= min.samples)\n  features.passed <- names(has.min.samples[has.min.samples])\n  expr.df <- expr.df[features.passed,]\n  \n  return(expr.df)\n}\n\nexpr_df = filter_on_tpm_read(expr.df = expr_df, tpm.df = expr_df, min.tpm = min_tpm, min.samples = min_samples)\n\n### convert to sample x gene matrix\nexpr_mat = t(expr_df)  # sample x gene\n\n### log\nif(do_log == TRUE){\n  expr_mat = log2(1+expr_mat)\n}\n\n### quantile normalization\nqn_expr <- function(expr_df){\n  # expr_df: sample x gene dataframe or matrix\n  rows = rownames(expr_df)\n  cols = colnames(expr_df)\n  expr_df = t(normalize.quantiles(t(expr_df)))\n  rownames(expr_df) = rows\n  colnames(expr_df) = cols\n  return(expr_df)\n}\n\nif(do_quantile == TRUE){\n  expr_mat = qn_expr(expr_mat)\n}\n\n### scale\nexpr_mat = scale(expr_mat)\n\n### pc\nexpr_svd = propack.svd(expr_mat, neig = n_pc)\npcs = expr_svd$u\n\n### remove pcs\nfit = lmFit(t(expr_mat),pcs)\nresidual_mat = expr_mat - pcs %*% t(fit$coefficients)\n\n### save\nresidual_df = as.data.frame(t(residual_mat))\nif(!is.null(start_col_df))\n  residual_df = cbind(start_col_df[rownames(residual_df),,drop=F], residual_df)\nwrite.table(residual_df, file = out_fn, sep = '\\t', quote = F, row.names = T, col.names = NA)\n",
    "created" : 1541124985066.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3010295447",
    "id" : "A38D1ABA",
    "lastKnownWriteTime" : 1519180532,
    "last_content_update" : 1519180532,
    "path" : "~/github/misc/cross_mappability/pc_correct_expr.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}