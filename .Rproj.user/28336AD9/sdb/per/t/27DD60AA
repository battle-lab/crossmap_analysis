{
    "collab_server" : "",
    "contents" : "# this script annotates cross-mappability of eqtl (S-G, snp-gene) pairs\n# i.e. finds genes nearby S cross-mappable with G.\n\nlibrary(argparser)\nlibrary(data.table)\n\n##### parse arguments ######\nargs <- arg_parser(\"program\");\nargs <- add_argument(args, \"-eqtl\", help=\"eqtl file\", default=\"/work-zfs/abattle4/ashis/progres/misc/cross_mappability/gtex_v7_symmetric_crossmap/trans_eqtl/trans_eqtl_cross_chr_mappability_0.8/Whole_Blood_cross_chr_map_trans_eqtl_fdr_0.05.txt\")\nargs <- add_argument(args, \"-cross\", help=\"cross-mappability file\", default=\"/work-zfs/abattle4/lab_data/annotation/mappability_hg19_gencode19/hg19_cross_mappability_strength_symmetric_mean.txt\")\nargs <- add_argument(args, \"-d\", help=\"max distance between a gene and the snp\", default=1e6)\nargs <- add_argument(args, \"-permute\", help=\"permute genes in the eqtl list\", default=FALSE)\nargs <- add_argument(args, \"-genperm\", help=\"permute from gencode, as opposed to permuting among eqtl hits\", default=FALSE)\nargs <- add_argument(args, \"-gencode\", help=\"gencode annotation file (txt format)\", default=\"/work-zfs/abattle4/lab_data/annotation/gencode.v19/gencode.v19.annotation.gene.txt\")\nargs <- add_argument(args, \"-o\", help=\"annotated eqtl file\", default=\"results/eqtl_annotated.txt\")\n\nargv = parse_args(args)\neqtl_fn = argv$eqtl\ncross_mappability_fn = argv$cross\nD = argv$d\ndo_permute = as.logical(argv$permute)\ngencode_permute = as.logical(argv$genperm)\ngencode_fn = argv$gencode\n#biomart_host = argv$mart\nout_fn = argv$o\n\n### read eqtl file\neqtl_df = read.table(eqtl_fn, sep = '\\t', header = T, stringsAsFactors = F, quote = \"\", comment.char = \"\")\n\n### read gencode file\ngencode_df = read.table(gencode_fn, sep = '\\t', header = T, stringsAsFactors = F, quote = \"\", comment.char = \"\")\nrownames(gencode_df) = gencode_df$gene_id\ngencode_genes = unique(gencode_df$gene_id)\n\n\n### permute the genes of eqtls, if instructed\npermute_eqtl_df <- function(eqtl_df){\n  # permute genes in the eqtl data frame\n  # note: if G1 is substitued by G2 in an eQTL, substitue every G1 by G2.\n  gene_2_idx = tapply(1:nrow(eqtl_df), eqtl_df$gene, min)\n  permuted_gene_2_idx = sample(as.numeric(gene_2_idx), size = length(gene_2_idx), replace = F)\n  names(permuted_gene_2_idx) = names(gene_2_idx)\n  permuted_idx = permuted_gene_2_idx[eqtl_df$gene]\n  eqtl_df$gene = eqtl_df$gene[permuted_idx]\n  eqtl_df$gene_chr = eqtl_df$gene_chr[permuted_idx]\n  eqtl_df$gene_start = eqtl_df$gene_start[permuted_idx]\n  eqtl_df$gene_end = eqtl_df$gene_end[permuted_idx]\n  return(eqtl_df)\n}\n\nglobal_permute_eqtl_df <- function(eqtl_df, gencode_df){\n  # permute genes in the eqtl data frame\n  # unlike permute_eqtl_df(), here a gene can be replaced by any gene from gencode\n  # note: if G1 is substitued by G2 in an eQTL, substitue every G1 by G2.\n  \n  eqtl_genes = unique(eqtl_df$gene)\n  permuted_genes = sample(gencode_df$gene_id, size = length(eqtl_genes), replace = F)\n  names(permuted_genes) = eqtl_genes\n  eqtl_df$gene = permuted_genes[eqtl_df$gene]\n  eqtl_df$gene_chr = gencode_df[eqtl_df$gene, 'chr']\n  eqtl_df$gene_start = gencode_df[eqtl_df$gene, 'start_pos']\n  eqtl_df$gene_end = gencode_df[eqtl_df$gene, 'end_pos']\n  return(eqtl_df)\n}\n\n\nif(paste0('', do_permute) == 'TRUE'){\n  if(paste0('', gencode_permute) == 'TRUE'){\n    eqtl_df <- global_permute_eqtl_df(eqtl_df, gencode_df)\n  } else {\n    eqtl_df <- permute_eqtl_df(eqtl_df)\n  }\n}\n\n\n### read cross-mappable genes\ncross_map = fread(input = cross_mappability_fn, sep = '\\t', header = F, stringsAsFactors = F, data.table = F, quote = \"\")\nif(ncol(cross_map)==2) {\n  # old format: only 2 columns. make symmetric, and fill 3rd column by 1 (equal weight)\n  cross_map = data.frame(V1=c(cross_map$V1, cross_map$V2), V2=c(cross_map$V2, cross_map$V1), stringsAsFactors = F)\n  cross_map$V3 = 1\n}\n# PROTEIN_CODING: crossmap only in protein coding\n\ncross_mappability = tapply(cross_map$V2, INDEX = cross_map$V1, FUN = c)\n\n\n\n# ### get TSS of every gene\n# all_genes = unique(c(gencode_genes, cross_map$V1, cross_map$V2))\n# all_genes_ensembl_gene_id = unlist(lapply(all_genes, function(x) strsplit(x, split='[.]')[[1]][1]))\n# #all_genes_version = unlist(lapply(all_genes, function(x) strsplit(x, split='[.]')[[1]][2]))\n# #ensembl = useMart(\"ensembl\", dataset = \"hsapiens_gene_ensembl\", host = biomart_host)\n# ensembl = useMart(\"ENSEMBL_MART_ENSEMBL\", dataset = 'hsapiens_gene_ensembl', host = biomart_host)\n# gene_attributes = c(\"ensembl_gene_id\",  \"chromosome_name\", \"transcription_start_site\")\n# #gene_attributes = c(\"ensembl_gene_id\",  \"chromosome_name\", \"transcript_start\")\n# tss <- getBM(attributes = gene_attributes,\n#              filters = \"ensembl_gene_id\",\n#              values = all_genes_ensembl_gene_id,\n#              mart = ensembl)\n# # x = colnames(tss)\n# # x[3] = \"transcription_start_site\"\n# # colnames(tss) = x\n# tss <- aggregate(transcription_start_site ~  ensembl_gene_id + chromosome_name, tss,  min)\n# #tss <- aggregate(transcript_start ~  ensembl_gene_id + chromosome_name, tss,  min)\n# if(nrow(tss) != length(unique(tss$ensembl_gene_id)))\n#   stop('multiple tss found for a single gene!!')\n# \n# \n# all_genes_df = data.frame(gene_id=all_genes, ensembl_gene_id=all_genes_ensembl_gene_id, stringsAsFactors = F)\n# tss = merge(all_genes_df, tss, by = 'ensembl_gene_id')\n# tss$chromosome_name = paste0('chr', tss$chromosome_name)\n# rownames(tss) = as.character(tss$gene_id)\n# if(nrow(tss) != nrow(all_genes_df))\n#   stop('could not find TSS of every gene')\n\n\n#tss with rownames as gene id, columns: chromosome_name, transcription_start_site\ntss_values =  as.integer(apply(gencode_df, MARGIN = 1, FUN = function(row){\n  ifelse(row['strand']==\"+\", row['start_pos'], row['end_pos'])\n}))\n\ntss = data.frame(chromosome_name = gencode_df[gencode_df$gene_id, 'chr'],\n                 transcription_start_site = tss_values, \n                 gene_id = gencode_df$gene_id,\n                 row.names = gencode_df$gene_id, \n                 stringsAsFactors = F)\n\n\n\n# For each snp-gene pair (S,G)\n#   get genes cross-mappable with G\n#   filter out cross-mappable genes with distance > D\n#   find gene-types of cross-mappable genes\n#   find gene-type of G\n#   add columns - gene_tss, gene_type cross_mappable_genes cross_tss cross_dist_to_snp cross_type\n\nget_snp_chr_pos <- function(s){\n  splitted_id = strsplit(s, split = '_')[[1]]\n  if('chr' != paste0(strsplit(splitted_id[1], split = '')[[1]][1:3], collapse = \"\")){\n    splitted_id[1] = paste0('chr', splitted_id[1])\n  }\n  return(list(chr=splitted_id[1], pos=as.numeric(splitted_id[2])))\n}\n\n\n### function to access tss fast\ntss_gene_to_idx <- new.env(hash = T)\ntss_genes = rownames(tss)\ntmp <- sapply(1:length(tss_genes), function(idx) tss_gene_to_idx[[tss_genes[idx]]] <<- idx )\n\nget_tss_entries <- function(genes, cols=NULL){\n  tss_indexes = sapply(genes, function(g) tss_gene_to_idx[[g]])\n  if(is.null(cols))\n    return(tss[tss_indexes,])\n  return(tss[tss_indexes,cols])\n}\n\n### function to access gencode fast\ngencode_gene_to_idx <- new.env(hash = T)\ngencode_genes = rownames(gencode_df)\ntmp <- sapply(1:length(gencode_genes), function(idx) gencode_gene_to_idx[[gencode_genes[idx]]] <<- idx )\n\nget_gencode_entries <- function(genes, cols=NULL){\n  gencode_indexes = sapply(genes, function(g) gencode_gene_to_idx[[g]])\n  if(is.null(cols))\n    return(gencode_df[gencode_indexes,])\n  return(gencode_df[gencode_indexes,cols])\n}\n\nfinal_annotated_eqtl_df = NULL\n\nn_in_parts = 10000\neqtl_part_indexes <- sort(unique(c(0, seq(from = n_in_parts, to = nrow(eqtl_df), by = n_in_parts), nrow(eqtl_df))))\neqtl_df = eqtl_df[with(eqtl_df, order(FDR)), ]\n\nfor(pidx in 1:(length(eqtl_part_indexes)-1)){\n  start_idx = eqtl_part_indexes[pidx]+1\n  end_idx = eqtl_part_indexes[pidx+1]\n  print(sprintf(\"%s: processing %d-%d\", Sys.time(), start_idx, end_idx))\n  \n  annotated_eqtl_df <- apply(eqtl_df[start_idx:end_idx,], MARGIN = 1, FUN = function(row){\n    S = as.character(row['snps'])\n    G = as.character(row['gene'])\n    \n    # prepare row with extra empty values to return when necessary\n    row['gene_tss'] =  get_tss_entries(G, 'transcription_start_site')\n    row['gene_type'] = get_gencode_entries(G, 'gene_type')\n    row['cross_type'] = NA\n    row['cross_mappable_genes'] = NA\n    row['cross_tss'] = NA\n    row['cross_tss_snp_d'] = NA\n    \n    row['gene_chr'] = get_gencode_entries(G, 'chr')\n    row['gene_start'] = get_gencode_entries(G, 'start_pos')\n    row['gene_end'] = get_gencode_entries(G, 'end_pos')\n    \n    S_chr_pos = get_snp_chr_pos(S)\n    row['snps_chr'] = S_chr_pos$chr\n    row['snps_pos'] = S_chr_pos$pos\n    \n    if(!'tissue' %in% names(row))\n      row['tissue'] = 'dummy_tissue'\n    \n    # get genes cross-mappable with G\n    cross_mappable_genes = tryCatch(cross_mappability[[G]], error = function(e) return(NULL))\n    cross_mappable_genes = intersect(cross_mappable_genes, rownames(tss))\n    if(is.null(cross_mappable_genes) || length(cross_mappable_genes) == 0 ){\n      return(row)\n    }\n    \n    # filter out cross-mappable genes with distance > D\n    cross_tss =  get_tss_entries(cross_mappable_genes)\n    cross_tss$d = abs(cross_tss$transcription_start_site - S_chr_pos$pos)\n    #cross_tss$d = abs(cross_tss$transcript_start - S_chr_pos$pos)\n    cross_tss = cross_tss[(cross_tss$chromosome_name == S_chr_pos$chr) & cross_tss$d <=D, ]\n    if(nrow(cross_tss) == 0){\n      return(row) \n    }\n    \n    # find gene-types of cross-mappable genes\n    cross_gene_types = get_gencode_entries(cross_tss$gene_id, 'gene_type')\n    \n    # add columns - gene_tss, gene_type cross_mappable_genes cross_tss cross_dist_to_snp cross_type, snp_chr, snp_pos\n    row['cross_mappable_genes'] = paste(cross_tss$gene_id, collapse = ',')\n    row['cross_tss'] = paste(cross_tss$transcription_start_site, collapse = ',')\n    row['cross_tss_snp_d'] = paste(cross_tss$d, collapse = ',')\n    row['cross_type'] = paste(cross_gene_types, collapse = ',')\n    return(row)\n  })\n  \n  if(class(annotated_eqtl_df) != 'matrix')\n    stop('something went wrong in the above apply() function.')\n  \n  annotated_eqtl_df = t(annotated_eqtl_df)\n  part_out_fn = sprintf(\"%s.part%d.txt\", out_fn, pidx)\n  write.table(annotated_eqtl_df, file = part_out_fn, sep = '\\t', row.names = F, col.names = T, quote = F, na = '')\n  \n  final_annotated_eqtl_df = rbind(final_annotated_eqtl_df, annotated_eqtl_df)\n  rm(annotated_eqtl_df)\n  gc(reset = T)\n}\n\nwrite.table(final_annotated_eqtl_df, file = out_fn, sep = '\\t', row.names = F, col.names = T, quote = F, na = '')\n",
    "created" : 1541125204349.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3041363533",
    "id" : "27DD60AA",
    "lastKnownWriteTime" : 1533119234,
    "last_content_update" : 1533119234,
    "path" : "~/github/misc/cross_mappability/annoate_eqtl_crossmap_protein_coding.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}